---
title: "[백준] 1012 유기농 배추"
description: "차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다..."
date: "2019-12-30"
modified_date: "2019-12-30"
tag: [백준, BOJ, DFS]
---

# Problem

[BOJ 1012](https://www.acmicpc.net/problem/1012)

차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.

(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)

한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.

예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.

(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)

|     |  R  |  R  |  R  |  R  |  R  |  R  |  R  |  R  |  R  |  R  |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
|  C  |  1  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  C  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
|  C  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |
|  C  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |  0  |  0  |
|  C  |  0  |  0  |  1  |  1  |  0  |  0  |  0  |  1  |  1  |  1  |
|  C  |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  1  |  1  |  1  |

위 표를 보면 1이 배추가 심어져 있는 영역이다. 1이 연속적으로 붙어있는 영역들의 개수를 구하는 문제이다.

# Solution

## 문제 접근 순서

1. 배열에서의 영역들의 개수를 구하는 문제.
2. dfs 또는 bfs를 사용해서 간단하게 component를 구할 수 있음.
3. 코드 보기 용이하게 class를 사용하여 구현.

## 문제 풀이

---

### dfs

```cpp
void dfs(int x, int y) {
		int direct[4][2] = { {1,0}, {0,1}, {-1,0}, {0,-1} };

		arr[x][y] = false;

		for (int i = 0; i < 4; i++) {
			int nextX = x + direct[i][0];
			int nextY = y + direct[i][1];

			if (0 > nextX || nextX >= m || 0 > nextY || nextY >= n)
				continue;

			if (arr[nextX][nextY] == true)
				dfs(nextX, nextY);
		}

	}
```

dfs를 기반으로 하여 풀이하였다. direct라는 2중 배열을 선언하였다. dfs 매 시도마다 동서남북을 판단하기 위해 배열에 동서남북에 마다 1씩 더하여 true인지 판별한다. true 조건이 성립하면 dfs가 진행된다.

dfs를 보면 보통 visited라는 배열을 선언하여 방문을 확인하는데 이 문제에서는 특별히 필요가 없어보여서 뺏다.

### Gragh개수 구하기

```cpp
int componentCount() {

		int graghNum = 0;

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				if (arr[j][i] == true) {
					graghNum++;
					dfs(j, i);
				}
			}
		}
		return graghNum;
	}
```

componentCount()라는 메서드를 만들어 카운트를 진행하였다. n, m 모두 스캔하고, gragh의 개수를 의미하는 graghNum이라는 변수를 증가시킨다.

조건으로는 arr이 true일 때만 동작하도록 하고, 나머지 경우의수는 생각하지 않는다.

이렇게 2중반복문을 사용하면 문제에서의 최대 조건인 50 \* 50번을 곱하게 되므로 2500번이 돌아간다. 문제 조건인 1초에 적합한 것을 확인할 수 있다.

여담이지만 **실행시간 1초 = 1,000,000,000번 동작하는 것**이라고 생각해도 된다고 한다.

# Source

[Github 전체소스](https://github.com/MinByeongChan/myMBC/tree/master/Codetest/baekjoon/1012_OrganicCabbage.cpp)
