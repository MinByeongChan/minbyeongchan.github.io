{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-PRMS-49993-post/","result":{"data":{"site":{"siteMetadata":{"title":"ByeongChan"}},"markdownRemark":{"id":"8b472bec-157d-5235-8c14-4c3ce1e7fd70","excerpt":"Problem PROGRAMMERS…","html":"<h1>Problem</h1>\n<p><a href=\"https://programmers.co.kr/learn/courses/30/lessons/49993\">PROGRAMMERS 스킬트리</a></p>\n<p>선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.</p>\n<p>예를 들어 선행 스킬 순서가 <code class=\"language-text\">스파크 → 라이트닝 볼트 → 썬더</code>일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.</p>\n<p>위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 <code class=\"language-text\">스파크 → 힐링 → 라이트닝 볼트 → 썬더</code>와 같은 스킬트리는 가능하지만, <code class=\"language-text\">썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더</code>와 같은 스킬트리는 불가능합니다.</p>\n<p>선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요.</p>\n<p><strong>제한 사항</strong></p>\n<ul>\n<li>스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다.</li>\n<li>스킬 순서와 스킬트리는 문자열로 표기합니다.</li>\n<li>예를 들어, C → B → D 라면 CBD로 표기합니다</li>\n<li>선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다.</li>\n<li>skill_trees는 길이 1 이상 20 이하인 배열입니다.</li>\n<li>\n<p>skill_trees의 원소는 스킬을 나타내는 문자열입니다.</p>\n<ul>\n<li>skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.</li>\n</ul>\n</li>\n</ul>\n<h1>Solution</h1>\n<h2>문제 접근 순서</h2>\n<ol>\n<li>Check함수를 만들어서 true, false 반환값으로 answer값 갱신.</li>\n<li>Check함수는 완전탐색으로 접근.</li>\n<li>skill<em>tree[i]의 인덱스(skill</em>tree[i][j]) 마다 skill인자가 있는지 없는지 확인.</li>\n</ol>\n<hr>\n<h2>문제 풀이</h2>\n<h3>Check함수</h3>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">//점검 함수</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">Check</span><span class=\"token punctuation\">(</span>string skill<span class=\"token punctuation\">,</span> string skill_tree<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> skillLen <span class=\"token operator\">=</span> skill<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// skill 길이</span>\n\t<span class=\"token keyword\">int</span> skill_treeLen <span class=\"token operator\">=</span> skill_tree<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//skill_trees 길이</span>\n\t<span class=\"token keyword\">int</span> idx <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// skill길이만큼 점검하는 인덱스</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> skill_treeLen<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> skillLen<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token comment\">//매번 skill안에 있는 인자들을 모두 점검</span>\n\t\t\t<span class=\"token comment\">//idx가 기준점이 되고, idx와 j의 일치 여부에 따라 점검이 진행됨</span>\n\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>skill_tree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> skill<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> idx <span class=\"token operator\">!=</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>skill_tree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> skill<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> idx <span class=\"token operator\">==</span> j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 스킬을 제대로 찍고 있으면 idx 증가</span>\n\t\t\t\tidx<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>2중 for문을 사용해서 완전 탐색으로 접근했다. 문제 조건으로 보아 완전탐색으로 접근해도 전혀 문제가 되지 않는 문제였다.</p>\n<p>변수 idx는 기준점을 나타낸다.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><strong>idx</strong></td>\n<td><strong>!</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>skill</strong></td>\n<td><strong>C</strong></td>\n<td>B</td>\n<td>D</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>skill_tree</strong>[i]</td>\n<td><strong>B</strong></td>\n<td>A</td>\n<td>C</td>\n<td>D</td>\n<td>E</td>\n</tr>\n</tbody>\n</table>\n<p>먼저 skill_tree의 각 인덱스는 skill의 모든 인자를 점검한다.</p>\n<p>2중포문 안에서 <code class=\"language-text\">B</code>가 <code class=\"language-text\">C</code>와 같은지 본다. 같지 않으면 넘어간다.</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><strong>idx</strong></td>\n<td></td>\n<td><strong>!</strong></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>skill</strong></td>\n<td>C</td>\n<td><strong>B</strong></td>\n<td>D</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"center\"><strong>skill_tree</strong>[i]</td>\n<td><strong>B</strong></td>\n<td>A</td>\n<td>C</td>\n<td>D</td>\n<td>E</td>\n</tr>\n</tbody>\n</table>\n<p>다음에 skill_tree의 <code class=\"language-text\">B</code>가 skill의 두번째 인자 <code class=\"language-text\">B</code>를 점검한다.</p>\n<p>이번엔 두 인자가 같다. 하지만 idx인자가 0을 가리키고 있는데 두번째 인자가 일치했다 나오므로 스킬트리에 어긋난 것으로 판단한다.</p>\n<p>이럴땐 false를 리턴한다.</p>\n<hr>\n</br>\n<p>이러한 방식으로 모든 인자를 탐색하는 <code class=\"language-text\">완전탐색</code>으로 접근하여 문제를 풀었다. 문제조건으로 skill의 길이는 20, skill_trees의 길이는 26이기 때문에 시간조건에서 매우 자유로운 문제였다.</p>\n<h1>Source</h1>\n<p><a href=\"https://github.com/MinByeongChan/myMBC/blob/master/Codetest/Programmers/49993_SkillTree.cpp\">Github 전체소스</a></p>","frontmatter":{"title":"[프로그래머스] 스킬트리","date":"January 28, 2020","description":null}}},"pageContext":{"slug":"/algorithm-PRMS-49993-post/","previous":{"fields":{"slug":"/algorithm-PRMS-42839-post/"},"frontmatter":{"title":"[프로그래머스] 소수 찾기"}},"next":{"fields":{"slug":"/algorithm-PRMS-12981-post/"},"frontmatter":{"title":"[프로그래머스] 영어 끝말잇기"}}}},"staticQueryHashes":["1246554614","2841359383"]}