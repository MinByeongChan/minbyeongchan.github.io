{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-BOJ-2178-post/","result":{"data":{"site":{"siteMetadata":{"title":"ByeongChan"}},"markdownRemark":{"id":"6fe9221f-853b-5596-858f-9228fd9965a0","excerpt":"Problem BOJ 2178 N×M크기의 배열로 표현되는 미로가 있다.  row row row row row row col 1 0 1 1 1 1 col 1 0 1 0 1 0 col 1 0 1 0 1 1 col 1 1 1 0 1 1 미로에서 1은 이동할 수 있는 칸을 나타내고,…","html":"<h1>Problem</h1>\n<p><a href=\"https://www.acmicpc.net/problem/2178\">BOJ 2178</a></p>\n<p>N×M크기의 배열로 표현되는 미로가 있다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">row</th>\n<th align=\"center\">row</th>\n<th align=\"center\">row</th>\n<th align=\"center\">row</th>\n<th align=\"center\">row</th>\n<th align=\"center\">row</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">col</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\"><strong>1</strong></td>\n</tr>\n<tr>\n<td align=\"center\">col</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">0</td>\n</tr>\n<tr>\n<td align=\"center\">col</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\"><strong>1</strong></td>\n</tr>\n<tr>\n<td align=\"center\">col</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">0</td>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\"><strong>1</strong></td>\n</tr>\n</tbody>\n</table>\n<p>미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.</p>\n<p>위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.</p>\n<h1>Solution</h1>\n<h2>문제 접근 순서</h2>\n<ol>\n<li><code class=\"language-text\">최소 경로</code>를 구해야하는 문제.</li>\n<li>최소 경로를 구하는 문제이니 <code class=\"language-text\">BFS</code>로 구현 (최소 경로는 BFS > DFS)</li>\n<li>좌표를 나타내야하는 x,y좌표상에서 배열에 queue를 어떻게 적용해야할까 -> pair사용해서 구현</li>\n</ol>\n<h2>예제 입력</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token number\">4</span> <span class=\"token number\">6</span>\n<span class=\"token number\">101111</span>\n<span class=\"token number\">101010</span>\n<span class=\"token number\">101011</span>\n<span class=\"token number\">111011</span></code></pre></div>\n<h2>bfs</h2>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">//BFS 함수</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">bfs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tqueue<span class=\"token operator\">&lt;</span>pair<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token operator\">>></span> q<span class=\"token punctuation\">;</span> <span class=\"token comment\">// x,y좌표를 나타내기위해 pair사용</span>\n\t\tq<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\tcnt <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>q<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t\t\t<span class=\"token keyword\">int</span> qSize <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// queue의 깊이</span>\n\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> qSize<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">int</span> x <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>first<span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token keyword\">int</span> y <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span><span class=\"token function\">front</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>second<span class=\"token punctuation\">;</span>\n\n\t\t\t\tq<span class=\"token punctuation\">.</span><span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t\t\t\t\t<span class=\"token keyword\">int</span> nextX <span class=\"token operator\">=</span> x <span class=\"token operator\">+</span> direct<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\t<span class=\"token keyword\">int</span> nextY <span class=\"token operator\">=</span> y <span class=\"token operator\">+</span> direct<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextX <span class=\"token operator\">></span> m <span class=\"token operator\">||</span> nextY <span class=\"token operator\">></span> n <span class=\"token operator\">||</span> nextX <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> nextY <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\t\t\t\t\t\t<span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>nextX<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextY<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t\t\t\t\t\t<span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n\n\t\t\t\t\t<span class=\"token comment\">// 마지막 인덱스에 도달하면 return</span>\n\t\t\t\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextX <span class=\"token operator\">==</span> m <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> nextY <span class=\"token operator\">==</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\t\t\t\t\t\t<span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n\t\t\t\t\tq<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">make_pair</span><span class=\"token punctuation\">(</span>nextX<span class=\"token punctuation\">,</span> nextY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t\tarr<span class=\"token punctuation\">[</span>nextX<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>nextY<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\tcnt<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token punctuation\">}</span></code></pre></div>\n<p>각 좌표는 pair를 사용하였다.\n미로 배열 arr에서 처음 좌표를 queue에 담고 BFS를 시작한다.</p>\n<p>BFS의 특성을 이해해야만 풀수 있는 문제이다. BFS는 <code class=\"language-text\">너비 우선 탐색</code>이기 때문에 각 시행마다 <code class=\"language-text\">깊이</code>를 구할 수 있다. 깊이를 구할 수 있다는 것은 상하좌우 모두 점검하고 넘어가도 1을 카운트 한다는 의미이다. 이러한 방식으로 깊이를 쉽게 얻을 수 있다.</p>\n<p>하지만 탈출조건이 주어지지 않으면 답이 이상해지므로 탈출조건을 적절하게 주어야 했다. 마지막 탈출조건에서 반환되면 (M,N)은 카운트 하지 않고 넘어가게 된다. 그래서 main g.result에 +1을 추가하여 출력한다.</p>\n<h1>Source</h1>\n<p><a href=\"https://github.com/MinByeongChan/myMBC/tree/master/Codetest/baekjoon/2178_Miro.cpp\">Github 전체소스</a></p>","frontmatter":{"title":"[백준] 2178 미로 탐색(최소경로, BFS)","date":"December 29, 2019","description":null}}},"pageContext":{"slug":"/algorithm-BOJ-2178-post/","previous":{"fields":{"slug":"/algorithm-BOJ-1260-post/"},"frontmatter":{"title":"[백준] 1260 DFS와 BFS"}},"next":{"fields":{"slug":"/algorithm-BOJ-11724-post/"},"frontmatter":{"title":"[백준] 11724 연결 요소의 개수"}}}},"staticQueryHashes":["1246554614","2841359383"]}