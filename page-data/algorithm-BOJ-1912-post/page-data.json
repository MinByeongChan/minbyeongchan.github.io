{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithm-BOJ-1912-post/","result":{"data":{"site":{"siteMetadata":{"title":"ByeongChan"}},"markdownRemark":{"id":"72c95718-5e0f-5948-bbf7-32dab98a21b7","excerpt":"Problem BOJ 1912 n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다. 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 2…","html":"<h1>Problem</h1>\n<p><a href=\"https://www.acmicpc.net/problem/1912\">BOJ 1912</a></p>\n<p>n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.</p>\n<p>예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.</p>\n<h1>Solution 1</h1>\n<h2>문제 접근 순서</h2>\n<ol>\n<li>제한시간 조건과 주어진 n의 최대값을 보고 완전탐색으로 접근하면 효율성 문제가 있을거같음.</li>\n<li>DP로 접근.</li>\n<li>한차례의 반복문이 시작되고 최대값을 계속해서 갱신</li>\n<li>배열의 인덱스 값이 음수일때를 분기점으로 하여 다시 최대값 갱신</li>\n</ol>\n<p>n의 값이 5000이상 일때 동작이 안됨…</p>\n<p>원인은 스택오버플로우 현상때문에 발생하는듯 하다.</p>\n<p>BinarySearch함수에서 적당한 시간에 빠져나오지 못하여 스택이 샇이고 도중에 중단되는 것 같다. 탈출조건을 잘 설정한 것 같은데 이상하게 안된다.</p>\n<h3>Source 1</h3>\n<p>{% highlight cpp %}\nvoid BinarySearch1(int i, long long int sum) {</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">long long int sum_temp = sum + v[i];\n\nif (sum_temp &lt; dp[i])\n\treturn;\n\n// Update dp[i](max value)\nif (sum_temp &gt; dp[i])\n\tdp[i] = sum_temp;\n\n// Searching for max value\nif (dp[i] &gt; mx)\n\tmx = dp[i];\n\nif (i &gt; N - 2)\n\treturn;\n\nBinarySearch1(i + 1, dp[i]);\n\nif (v[i + 1] &lt; 0 &amp;&amp; i &lt; N-3)\n\tBinarySearch1(i + 2, 0);</code></pre></div>\n<p>}\n{% endhighlight %}</p>\n<h1>Solution 2</h1>\n<h2>문제 접근 순서</h2>\n<p><code class=\"language-text\">탑다운</code> 방식으로 풀이할때 리턴값을 제대로 설정을 못해 <code class=\"language-text\">바텀업</code> 접근 방식으로 풀이를 진행하였다.</p>\n<ol>\n<li>각 벡터에 대한 입력을 받은 후 dp벡터에 그대로 복사.</li>\n<li>dp[i-1]이 음수일때를 체크.</li>\n<li>dp[i-1] + dp[i] 가 양수이면 계속 dp[i]에 더함.\n(계속 더하는 것이 최대값을 갖는 방법이기 때문)</li>\n<li>매 반복시 최대값을 검사.</li>\n</ol>\n<h3>Source 2</h3>\n<p>{% highlight cpp %}\nint main() {\ncin >> N;\nv.resize(N);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (int i = 0; i &lt; N; i++)\n\tcin &gt;&gt; v[i];\n\n// duplicate Input vector\ndp = v;\n\n//Binary search\n//BinarySearch(0, 0);\n\n// when First index is minus value,\nif (dp[0] &gt; mx)\n\tmx = dp[0];\n\nfor (int i = 1; i &lt; N; i++) {\n\n\tif (dp[i - 1] &gt; 0 &amp;&amp; dp[i] + dp[i - 1] &gt; 0) {\n\t\tdp[i] += dp[i - 1];\n\t}\n\tif (mx &lt; dp[i])\n\t\tmx = dp[i];\n}\n\ncout &lt;&lt; mx;\n\nreturn 0;</code></pre></div>\n<p>}\n{% endhighlight %}</p>\n<p>문제만 보면 별로 어려울것 같지 않은 문제였지만 생각보다 오래걸린 문제였다. 아직 탈출조건을 잘 설정 못해서 계속 해맷다. 갈길이 멀다.</p>","frontmatter":{"title":"[백준] 1912 연속합","date":"December 10, 2019","description":null}}},"pageContext":{"slug":"/algorithm-BOJ-1912-post/","previous":{"fields":{"slug":"/algorithm-BOJ-2941-post/"},"frontmatter":{"title":"[백준] 2941 크로아티아 알파벳"}},"next":{"fields":{"slug":"/algorithm-BOJ-1806-post/"},"frontmatter":{"title":"[백준] 1806 부분합"}}}},"staticQueryHashes":["1246554614","2841359383"]}